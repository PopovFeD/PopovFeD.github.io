## Универсальные алгоритмы

Шаблоны функций позволяют создавать универсальные алгоритмы, которые могут работать с любыми типами данных, поддерживающими необходимые операции.

```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add(3, 4) << std::endl;     // Вывод: 7
    std::cout << add(3.5, 4.5) << std::endl; // Вывод: 8.0
    return 0;
}
```

## Обобщенные функции сравнения

Шаблоны функций позволяют создавать обобщенные функции для сравнения значений разных типов.

```cpp
template <typename T>
bool equals(T a, T b) {
    return a == b;
}

int main() {
    std::cout << std::boolalpha;
    std::cout << equals(3, 3) << std::endl;          // Вывод: true
    std::cout << equals(3.5, 3.5) << std::endl;      // Вывод: true
    std::cout << equals(3, 4) << std::endl;          // Вывод: false
    std::cout << equals('a', 'a') << std::endl;      // Вывод: true
    return 0;
}
```

## Шаблонные функции для работы с контейнерами

Шаблоны функций позволяют создавать универсальные функции для работы с различными контейнерами.

```cpp
#include <vector>
#include <list>
#include <iostream>

template <typename Container>
void printContainer(const Container& container) {
    for (const auto& element : container) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"hello", "world"};
    
    printContainer(vec); // Вывод: 1 2 3 4 5
    printContainer(lst); // Вывод: hello world
    
    return 0;
}
```

## Шаблоны функций для математических операций

Шаблоны функций позволяют создавать универсальные математические операции, которые могут работать с разными числовыми типами.

```cpp
template <typename T>
T multiply(T a, T b) {
    return a * b;
}

int main() {
    std::cout << multiply(3, 4) << std::endl;       // Вывод: 12
    std::cout << multiply(3.5, 4.5) << std::endl;   // Вывод: 15.75
    return 0;
}
```

## Сортировка с использованием компараторов

Шаблоны функций позволяют создавать обобщенные функции сортировки с использованием различных компараторов.

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

template <typename T, typename Compare>
void sort(std::vector<T>& vec, Compare comp) {
    std::sort(vec.begin(), vec.end(), comp);
}

int main() {
    std::vector<int> vec = {4, 2, 5, 1, 3};
    
    sort(vec, std::greater<int>()); // Сортировка по убыванию
    
    for (int i : vec) {
        std::cout << i << " "; // Вывод: 5 4 3 2 1
    }
    return 0;
}
```

## Специализация шаблонов функций

Шаблоны функций позволяют создавать специализированные версии для определённых типов данных.

```cpp
#include <iostream>

// Основной шаблон функции
template <typename T>
void printType(T value) {
    std::cout << "Тип данных: " << typeid(T).name() << ", значение: " << value << std::endl;
}

// Специализация для типа int
template <>
void printType(int value) {
    std::cout << "Это целое число, значение: " << value << std::endl;
}

int main() {
    printType(10);           // Вывод: Это целое число, значение: 10
    printType(3.14);         // Вывод: Тип данных: double, значение: 3.14
    printType("Hello");      // Вывод: Тип данных: PKc, значение: Hello
    return 0;
}
```

## Использование с `decltype` и `auto`

Шаблоны функций могут работать с `decltype` и `auto` для автоматического определения типа возвращаемого значения.

```cpp
#include <iostream>

template <typename T1, typename T2>
auto add(T1 a, T2 b) -> decltype(a + b) {
    return a + b;
}

int main() {
    std::cout << add(3, 4.5) << std::endl;   // Вывод: 7.5
    return 0;
}
```
