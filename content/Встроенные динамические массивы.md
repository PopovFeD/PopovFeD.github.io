Встроенные динамические массивы в C++ представляют собой массивы, размер которых может изменяться во время выполнения программы. Они обеспечивают гибкость по сравнению с статическими массивами, размер которых должен быть известен и фиксирован во время компиляции. В C++ для работы с динамическими массивами используются операторы `new` и `delete`.

## Выделение и освобождение памяти для динамических массивов

### Выделение памяти для динамического массива

Для выделения памяти для динамического массива используется оператор `new`, который возвращает указатель на первый элемент массива:

```cpp
int* arr = new int[10]; // выделение памяти для массива из 10 целых чисел
```

### Освобождение памяти для динамического массива

Для освобождения памяти, выделенной для динамического массива, используется оператор `delete[]`:

```cpp
delete[] arr; // освобождение памяти для массива из 10 целых чисел
```

## Перераспределение памяти

При работе с динамическими массивами может возникнуть необходимость изменить размер массива. *Встроенные средства C++ не предоставляют прямого способа изменения размера массива*, поэтому это достигается созданием нового массива, копированием элементов из старого массива и освобождением памяти старого массива:

```cpp
#include <iostream>

int main() {
    int size = 5;
    int* arr = new int[size]; // выделение памяти для первоначального массива

    // Заполнение массива
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 10;
    }

    // Изменение размера массива
    int newSize = 10;
    int* newArr = new int[newSize];

    // Копирование элементов в новый массив
    for (int i = 0; i < size; ++i) {
        newArr[i] = arr[i];
    }

    // Освобождение памяти старого массива
    delete[] arr;
    arr = newArr; // теперь arr указывает на новый массив

    // Заполнение оставшихся элементов нового массива
    for (int i = size; i < newSize; ++i) {
        arr[i] = i * 10;
    }

    // Вывод нового массива
    for (int i = 0; i < newSize; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    // Освобождение памяти
    delete[] arr;

    return 0;
}
```

## Доп: Использование `std::vector` вместо встроенных динамических массивов

Для упрощения работы с динамическими массивами и избежания ошибок управления памятью в C++ рекомендуется использовать контейнер `std::vector` из стандартной библиотеки (STL). `std::vector` автоматически управляет памятью и предоставляет удобные методы для работы с динамическими массивами.

### Пример использования `std::vector`:

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec; // создание вектора

    // Добавление элементов
    for (int i = 0; i < 5; ++i) {
        vec.push_back(i * 10);
    }

    // Вывод элементов
    for (int i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
