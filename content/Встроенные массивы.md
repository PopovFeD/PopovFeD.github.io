Если `T` некоторый тип, `N` - константа или выражение, вычисляемое во время компиляции, то инструкция  

```cpp
T a[N];
```

объявляет переменную `a` типа **«массив из `N` элементов типа `T`»** (array of `N` elements of the type `T`). Тип `N` должен иметь неявное приведение к типу `std::size_t`, а его значение, называемое размером массива, должно быть больше нуля. Массив располагается в непрерывном отрезке памяти, под каждый элемент массива выделяется `sizeof(T)` байт, соответственно размер памяти, необходимой для размещения всего массива, равен `N*sizeof(T)` байт. Эта величина ограничена сверху платформой и компилятором. Тип массива обозначается как `T[N]`, то есть он включает тип элементов и размер массива. Таким образом, массивы, имеющие одинаковый тип элементов, но разный размер, будут иметь разный тип. 

Такие массивы еще называют **`встроенными массивами`** (regular arrays), чтобы подчеркнуть отличие от других вариантов массивов, термин «массив» используется в программировании и в том числе в C++ достаточно широко.  
Вот примеры правильных объявлений массивов:  

```cpp
#include <iostream>

using namespace std;

constexpr int Square (int a)
{
	return a * a;
}

int main() {
    const int N = 8;
    int a1[1];
    int a2[N];
    int a3['Q'];
    int a4[Square(2)];
}
```

Массивы можно инициализировать при их объявлении:

```cpp
int arr[5] = {1, 2, 3, 4, 5}; // массив с начальным значением
```

>[!info] Важно
>Выход за границы массива не контролируется, что может привести к неопределенному поведению.

## Ограничения
* Нельзя объявить массив, элементы которого имеют тип `void`.  
* Нельзя объявить массив ссылок.  

```cpp
int u, v;int &rr[2] = { u, v }; // ошибка
```

Вместо этого можно использовать массив константных указателей.  

```cpp
int * const rr[2] = { &u, &v };
```

* Нельзя объявить массив функций.  

```cpp
int ff[2](double); // ошибка
```

Вместо этого можно использовать массив указателей на функцию.  

```cpp
int (*ff[2])(double);
```

* Массив нельзя объявить с помощью ключевого слова `auto`.  

```cpp
auto x[2] = {1, 2}   // ошибка
```

Квалификатор `const` не применим к типу массива, а только к типам его элементов.  

```cpp
using I4 = int[4];const I4 ci; // то же, что и const int ci[4];
```
