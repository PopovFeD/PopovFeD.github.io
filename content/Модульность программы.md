>**Модульность** — это принцип разделения программы на независимые, логически завершенные части (модули), которые могут быть разработаны, протестированы и отлажены отдельно. Модульность упрощает разработку, обслуживание и масштабирование программного обеспечения.

## Варианты создания модулей

### Файловая структура

Импортировать `.cpp` файлы напрямую в C++ возможно, но не рекомендуется и не является стандартной практикой, также как это возможно, но не рекомендуется в Python с помощью `import`. Вместо этого используется механизм включения заголовочных файлов и компиляции нескольких исходных файлов вместе. Вот как это делается:

1. **Создание заголовочного файла (.h)**

   Заголовочный файл содержит *объявления* функций, классов и переменных, которые будут использоваться в других частях программы.

   ```cpp
   // my_module.h
   #ifndef MY_MODULE_H
   #define MY_MODULE_H

   void myFunction();

   #endif
   ```

2. **Создание исходного файла (.cpp)**

   Исходный файл содержит *определения* функций и методов классов.

   ```cpp
   // my_module.cpp
   #include "my_module.h"
   #include <iostream>

   void myFunction() {
       std::cout << "Hello from myFunction!" << std::endl;
   }
   ```

3. **Включение заголовочного файла в основной программе**

   Включите заголовочный файл, чтобы использовать функции и классы из другого модуля.

   ```cpp
   // main.cpp
   #include "my_module.h"

   int main() {
       myFunction();
       return 0;
   }
   ```

4. **Компиляция нескольких файлов**

   Скомпилируйте все исходные файлы вместе, чтобы они могли ссылаться друг на друга.

   ```sh
   g++ main.cpp my_module.cpp -o my_program
   ```

Таким образом, вместо прямого импорта `.cpp` файлов, в C++ используется компиляция всех необходимых файлов с включением заголовочных файлов для деклараций. 

### Пространства имен (namespaces)

   - Используются для логической группировки функций, классов и переменных, чтобы избежать конфликтов имен.

   ```cpp
   namespace MyModule {
       void myFunction() {
           std::cout << "Hello from MyModule!" << std::endl;
       }
   }

   int main() {
       MyModule::myFunction();
       return 0;
   }
   ```

### Классы и объекты

   - Создание классов для объединения данных и методов, работающих с этими данными.

   ```cpp
   class MyModule {
   public:
       void myFunction() {
           std::cout << "Hello from MyModule class!" << std::endl;
       }
   };

   int main() {
       MyModule module;
       module.myFunction();
       return 0;
   }
   ```

### Библиотеки

   - Статические библиотеки (.lib) и динамические библиотеки (.dll/.so).

   ```cpp
   // Статическая библиотека
   // Создание: ar rcs libmymodule.a my_module.o
   // Использование: g++ main.cpp -L. -lmymodule

   // Динамическая библиотека
   // Создание: g++ -shared -o libmymodule.so my_module.o
   // Использование: g++ main.cpp -L. -lmymodule
   ```

### Плагины

   - Использование динамически подгружаемых модулей для расширения функциональности без изменения основного кода.
