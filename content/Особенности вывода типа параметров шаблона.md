## Кратко

Вывод типа параметров шаблона (template argument deduction) в C++ — это механизм, который позволяет компилятору автоматически определять типы шаблонных параметров из аргументов, переданных в шаблон. Это упрощает использование шаблонов, не требуя явного указания всех типов.

### Резюме правил

- **Прямой вывод**: Типы выводятся непосредственно из аргументов.
- **Универсальные шаблоны**: Поддерживают вывод нескольких параметров.
- **auto и decltype**: Позволяют выводить типы на основе выражений.
- **Ограничения**: Возможны ошибки при неявных преобразованиях типов и сложных шаблонах.

---

## Основные особенности

### Что такое вывод типа параметров шаблона?

Вывод типа параметров шаблона — это процесс, при котором компилятор автоматически определяет типы шаблонных параметров на основе переданных аргументов, не требуя их явного указания.

### Принципы работы

- **Автоматическое определение**: Компилятор анализирует аргументы функции или класса и сопоставляет их с шаблонными параметрами.
- **Шаблоны функций и классов**: Вывод типов работает как для шаблонов функций, так и для шаблонов классов.

### Примеры и правила

#### Пример 1: Вывод типа для шаблонной функции

```cpp
template<typename T>
void print(T value) {
    std::cout << value << std::endl;
}

int main() {
    print(10);       // T выводится как int
    print(3.14);     // T выводится как double
    print("Hello");  // T выводится как const char*
    return 0;
}
```

#### Пример 2: Вывод типа с несколькими параметрами

```cpp
template<typename T1, typename T2>
void display(T1 a, T2 b) {
    std::cout << a << " and " << b << std::endl;
}

int main() {
    display(1, 2.5);    // T1 выводится как int, T2 выводится как double
    display("Hi", 42);  // T1 выводится как const char*, T2 выводится как int
    return 0;
}
```

#### Пример 3: Шаблон класса с выводом типа

```cpp
template<typename T>
class Container {
public:
    Container(T value) : value(value) {}
    T get() const { return value; }
private:
    T value;
};

int main() {
    Container<int> intContainer(5);      // T явно указан как int
    Container<double> doubleContainer(3.14); // T явно указан как double
    auto intValue = intContainer.get();    // intValue имеет тип int
    auto doubleValue = doubleContainer.get(); // doubleValue имеет тип double
    return 0;
}
```

### Пример 4: Вывод типа с использованием auto

```cpp
template<typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    auto result = add(1, 2);         // result имеет тип int
    auto result2 = add(1.0, 2.5);   // result2 имеет тип double
    return 0;
}
```

### Правила и ограничения

#### Правило 1: Прямой вывод аргументов

Вывод типа происходит непосредственно из аргументов, переданных в шаблон, например, в шаблоне функции или класса.

#### Правило 2: Вывод для универсальных шаблонов

Если в шаблоне функции или класса используются несколько аргументов, компилятор выводит типы для всех шаблонных параметров одновременно.

```cpp
template<typename T1, typename T2>
void example(T1 a, T2 b) {
    // T1 и T2 выводятся из аргументов
}

int main() {
    example(10, 20.5);  // T1 = int, T2 = double
    example("Hello", 42);  // T1 = const char*, T2 = int
    return 0;
}
```

#### Правило 3: Вывод типа с использованием auto и decltype

```cpp
auto multiply(int x, double y) {
    return x * y;  // Вернет double, так как double имеет более высокий приоритет
}

decltype(auto) divide(int x, double y) {
    return x / y;  // Использует тип выражения x / y
}
```

#### Правило 4: Ограничения и ошибки

- **Неявные конверсии**: Вывод типа может вызывать ошибки, если типы неявно не преобразуются.
- **Нет шаблонного параметра по умолчанию**: Для некоторых более сложных шаблонов, может потребоваться явное указание параметров.

```cpp
template<typename T = int>
void func(T value) {
    // T по умолчанию int
}

int main() {
    func(10);  // T выводится как int
    func(3.14); // T выводится как double, но нужно указывать T явно, если необходим другой тип
    return 0;
}
```
