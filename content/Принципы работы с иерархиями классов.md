## Ключевое

Работа с иерархиями классов в C++ требует соблюдения нескольких принципов, таких как инкапсуляция, наследование, полиморфизм, использование виртуальных функций и соблюдение принципов SOLID.

---

## Методы, которым посвящены отдельные страницы

1. **[[Инкапсуляция]]**

2. **[[Наследование]]**

3. **[[Полиморфизм]]**

4. **[[Виртуальные функции]]**

5. **[[Чисто виртуальные функции и интерфейсы]]**

## Новые принципы

### Принципы SOLID

- **Single Responsibility Principle (SRP)**: Класс должен иметь одну ответственность.
- **Open/Closed Principle (OCP)**: Классы должны быть открыты для расширения, но закрыты для модификации.
- **Liskov Substitution Principle (LSP)**: Объекты базового класса должны заменяться объектами производного класса без нарушения корректности. см. [[Принцип подстановки Лисков]].
- **Interface Segregation Principle (ISP)**: Интерфейсы не должны заставлять классы реализовывать методы, которые они не используют.
- **Dependency Inversion Principle (DIP)**: Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.

### Использование базовых и производных классов

- **Явное приведение типов**: Использование оператора приведения типов `dynamic_cast` для безопасного приведения указателей и ссылок на базовые и производные классы.
- **Избегание множественного наследования**: Предпочтение композиции над множественным наследованием для избегания сложностей и неоднозначностей.

```cpp
class Base1 {};
class Base2 {};

class Derived : public Base1, public Base2 {
    // Множественное наследование
};
```
