Перед тем, как приступать, давайте создадим исходный .cpp файл, с которым и будем работать в дальнейшем.

```cpp
#include <iostream>
using namespace std;
#define RETURN return 0
int main() {
	cout << "Hello, world!" << endl;
	RETURN;
	}
```

## 1) Препроцессинг

Самая первая стадия компиляции программы.

>**Препроцессор** — это _макро процессор_, который преобразовывает вашу программу для дальнейшего компилирования. На данной стадии происходит работа с препроцессорными директивами. Например, препроцессор добавляет хэдеры в код (**#include**), убирает комментирования, заменяет макросы (**#define**) их значениями, выбирает нужные куски кода в соответствии с условиями **#if**, **#ifdef** и **#ifndef**.

Хэдеры, включенные в программу с помощью директивы **#include**, рекурсивно проходят стадию препроцессинга и включаются в выпускаемый файл. Однако, каждый хэдер может быть открыт во время препроцессинга несколько раз, поэтому, обычно, используются специальные препроцессорные директивы, предохраняющие от циклической зависимости.

Получим препроцессированный код в выходной файл **driver.ii** (прошедшие через стадию препроцессинга C++ файлы имеют расширение **.ii**).

Взглянув на тело функции _main_ в новом сгенерированном файле, можно заметить, что макрос RETURN был заменен:

```cpp
int main() {
	cout << "Hello, world!" << endl;
    return 0;
    }
```

Вот как выглядит на .ii файл:

[drive####r.ii](https://pastebin.com/7EDJTPKK)

[[7EDJTPKK.cpp]]

В новом сгенерированном файле также можно увидеть огромное количество новых строк, это различные библиотеки и хэдер iostream.

## 2) Компиляция

На данном шаге (g++) выполняет свою главную задачу — компилирует, то есть преобразует полученный на прошлом шаге код без директив в _ассемблерный код_. Это промежуточный шаг между высокоуровневым языком и машинным (бинарным) кодом.

>**Ассемблерный код** — это доступное для понимания человеком представление машинного кода.

Мы можем все также посмотреть и прочесть полученный результат. Но для того, чтобы машина поняла наш код, требуется преобразовать его в машинный код, который мы и получим на следующем шаге.

## 3) Ассемблирование

Так как x86 процессоры исполняют команды на бинарном коде, необходимо перевести ассемблерный код в машинный с помощью **ассемблера**.

Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в _объектном файле_.

>**Объектный файл** — это созданный ассемблером промежуточный файл, хранящий кусок машинного кода. Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется _объектным кодом_.

Далее возможно сохранение данного объектного кода в _статические библиотеки_ для того, чтобы не компилировать данный код снова.

Но на данном шаге еще ничего не закончено, ведь объектных файлов может быть много и нужно их всех соединить в единый исполняемый файл с помощью компоновщика (линкера). Поэтому мы переходим к следующей стадии.

## 4) Компоновка

>**Компоновщик (линкер)** связывает все объектные файлы и статические библиотеки в единый исполняемый файл, который мы и сможем запустить в дальнейшем. Для того, чтобы понять как происходит связка, следует рассказать о _таблице символов_.

>**Таблица символов** — это структура данных, создаваемая самим компилятором и хранящаяся в самих объектных файлах. Таблица символов хранит имена переменных, функций, классов, объектов и т.д., где каждому идентификатору (символу) соотносится его тип, область видимости. Также таблица символов хранит адреса ссылок на данные и процедуры в других объектных файлах.

Именно с помощью таблицы символов и хранящихся в них ссылок линкер будет способен в дальнейшем построить связи между данными среди множества других объектных файлов и создать единый исполняемый файл из них.

Получим исполняемый файл **driver**

## 5) Загрузка

Последний этап, который предстоит пройти нашей программе — вызвать загрузчик для загрузки нашей программы в память. На данной стадии также возможна подгрузка _динамических библиотек_.
